package ui.smartpro.rxjava.les5subscribeonobserveon;

public class SubscribeOn {
//subscribeOn
//Т.е. вся работа по генерации данных была выполнена в потоке, в котором был вызван метод subscribe.
// Но это можно легко изменить. Мы можем настроить Observable так, чтобы метод call был выполнен в другом потоке.
// Для этого используется оператор subscribeOn, в который нам необходимо передать Scheduler.
//
//Шедулер можно рассматривать просто как обертку над Executor. Observable поручит выполнение кода шедулеру,
// а тот уже выполнит его в потоке своего Executor.
//
//RxJava предоставляет нам несколько готовых шедулеров, например:
//Schedulers.io - для выполнения IO операций (сеть, диск)
//Schedulers.computation - для выполнения вычислений
//Schedulers.newThread - шедулер с произвольным новым потоком
//
//Насколько я понял, почитав различные источники, есть ощутимая разница между io и computation шедулерами.
//
//io - может содержать сколько угодно потоков, и предполагается, что задачи выполняемые в этих потоках
// не будут серьезно загружать процессор. Если все потоки заняты, то под каждую новую задачу просто выделяется новый поток.
//
//computation - максимальное число потоков ограничено количеством ядер процессора. Если все потоки заняты,
// то новые задачи помещаются в очередь.
//
//Т.е. если вы IO-операции будете выполнять в computation шедулере, то получите ограничение
// по количеству потоков и ваши операции будут выстраиваться в очередь.
// При одновременной загрузке большого количества файлов из сети это может существенно снизить общую скорость загрузки.
//
//А если вы вычислительные операции, которые сильно грузят процессор, будете выполнять в io шедулере,
// вы получите множество очень загруженных потоков, что может отрицательно сказаться на общей производительности.

//Также мы всегда можем использовать свой Executor и на его основе создать шедулер с помощью метода:
//Schedulers.from(Executor executor)

//Давайте используем IO-шедулер. Перепишем код создания Observable, добавив туда вызов метода subscribeOn:

Observable<Integer> observable = Observable
        .create(onSubscribe)
        .subscribeOn(Schedulers.io());
//Теперь метод call будет выполнен в отдельном потоке, который предоставит IO-шедулер
//
//Результат:
//0 subscribe [main]
//0 done [main]
//0 call [RxIoScheduler-2]
//100 observer onNext value = 0 [RxIoScheduler-2]
//200 observer onNext value = 1 [RxIoScheduler-2]
//300 observer onNext value = 2 [RxIoScheduler-2]
//300 observer onCompleted [RxIoScheduler-2]
//
//Обратите внимание, что на этот раз метод subscribe не заблокировал UI-поток,
// и done идет сразу после subscribe без задержки по времени.
//Работа по генерации элементов в методе call была выполнена в отдельном потоке.
// Но это привело к тому, что в этом же потоке данные были получены (onNext) подписчиком.
// Это не всегда может быть удобно, поэтому RxJava предоставляет возможность и для этого случая указать шедулер.
}
